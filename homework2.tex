\documentclass{article}
\usepackage{listings}
\usepackage{amsmath}
\usepackage{fullpage}
\usepackage{tabularx}
\usepackage{graphicx}
\usepackage{cite}
\begin{document}
\lstset{language=python, tabsize=4}
\title{CS 516 homework 2}
\author{Yuchen Hou}
\maketitle

\section{TM: change}

\subsection{10-change-TM is equivalent to FA}
The smallest class is Regular, because any 10-change TM is equivalent to a FA. Given any 10-change TM N, we can construct FA M to simulate N:
\begin{enumerate}
	\item guess all 10 changes N will make and generate the input tape with changes
	\item when N moves left, M moves left
	\item when N moves right, M moves right
	\item use M's read to simulate N's write
	\item use finite control to keep track of 10 changes
\end{enumerate}

\subsection{10-change-per-cell TM simulates TM}
Given TM N, we can construct a 10-change-per-cell TM M to simulate N:
\begin{enumerate}
	\item if N writes a symbol: shift the head and symbols in the
	non-blank region to the blank region on the right
	\item if N makes any other move: make the same move
\end{enumerate}
Notice that M changes a cell at most twice.

\section{1-turn TM}
The smallest class is Regular, because given 1-turn TM M, we can construct FA N to simulate M:
\begin{enumerate}
	\item the input of the FA has 4 tracks
	\item track 1: the 1st symbol the TM reads during the right move
	\item track 2: the last symbol the TM reads during the right move
	\item track 3: the 1st symbol the TM reads during the left move
	\item track 4: the last symbol the TM reads during the left move
	\item the FA makes only one rightward move and simulate the backward move of the TM along the way		
\end{enumerate}

\section{Jump TM}

Given TM N, we can construct a jump TM M to simulate N:
\begin{enumerate}
	\item if N moves left: move left(jump left, move right a few times, stop(guess when to stop) and mark), move right to verify the marked cell is right, jump left, move right a few times, stop at mark
	\item if N makes any other move: make the same move
\end{enumerate}

\section{Simulating 2 counters with 1 queue}
The queue simulates 2 counters: A and B. The queue alphabet = \{A, B, 1\}.
\begin{lstlisting}

def __init__():
	"""
	initialize 2 counters: A = 0, B = 0
	"""
	queue.enqueue(A)
	queue.enqueue(B)
	
def increment(X):
	"""
	increment counter X
	
	@param: X is the counter to be incremented, either A or B
	"""
	symbol = none
	while (symbol != X):
		symbol = queue.dequeue()
		queue.enqueue(symbol)
	queue.enqueue(1)

def decrement(X):
	"""
	decrement counter X
	
	@param: X is the counter to be decremented, either A or B
	@crash: if X == 0
	"""
	symbol = none
	while (symbol != X):
		symbol = queue.dequeue()
		queue.enqueue(symbol)
	symbol = queue.dequeue()
	assert(symbol == 1)
	
def is_zero(X):
	"""
	test if counter X == 0
	
	@param: X is the counter to be decremented, either A or B
	@return: true if X == 0, false otherwise
	"""
	symbol = none
	while (symbol != X):
		symbol = queue.dequeue()
		queue.enqueue(symbol)
	symbol = queue.dequeue()	
	queue.enqueue(symbol)
	if symbol == 1:
		return false
	else:
		return true
	
\end{lstlisting}

\end{document}
